package com.example.mozzie.mozlearning.m_unittest;

/**
 * Created by mozzie on 17/3/15.
 */

//import org.junit.Test;

import java.util.LinkedList;
import java.util.List;

import static junit.framework.Assert.assertNotNull;
//import static org.mockito.Mockito.*;

public class MockitoTestwithStatic {
//
////    private LinkedList mockedList = mock(LinkedList.class);
//
//    @Test
//    public void testINotNull(){
////        mockedList.add("one");
////        mockedList.add("two");
////
////        verify(mockedList).add("one");
//
//        assertNotNull(mockedList);
//    }
//
//    @Test
//    public void test_function(){
//        //You can mock concrete classes, not just interfaces
//        LinkedList mockedList = mock(LinkedList.class);
//
//        //stubbing
//        when(mockedList.get(0)).thenReturn("first");
////        when(mockedList.get(1)).thenThrow(new RuntimeException());
//        when(mockedList.get(1)).thenReturn("second");
//        //following prints "first"
//        System.out.println(mockedList.get(0));
//
//        //following throws runtime exception
//        System.out.println(mockedList.get(1));
//
//        //following prints "null" because get(999) was not stubbed
//        System.out.println(mockedList.get(999));
//
//        //Although it is possible to verify a stubbed invocation, usually it's just redundant
//        //If your code cares what get(0) returns, then something else breaks (often even before verify() gets executed).
//        //If your code doesn't care what get(0) returns, then it should not be stubbed. Not convinced? See here.
//        verify(mockedList).get(0);
//    }
}
